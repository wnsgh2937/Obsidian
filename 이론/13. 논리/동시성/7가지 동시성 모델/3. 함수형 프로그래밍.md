동시성이 문제가 되는 부분은 어떤 **가변**인 **공유 변수**에 여러 쓰레드가 접근하여 읽고 쓰는 경우이다.

생각해보면, 공유변수가 아니어서 한 쓰레드만이 접근할 수 있다면 동시성을 걱정하지 않아도된다.

또한 생각해보면 변수가 불변이라면 동시성을 걱정하지 않아도된다. (읽기만 가능하므로)

하지만 가변이면서 공유 변수인 경우에 동시성 문제가 된다.

함수형 프로그래밍은 이러한 가변 변수를 제외하는 관점으로 동시성을 해결한다.

근데 사실, 뭐가 확 와닿지 않는 것은 사실이다.

일반적인 명령형 프로그래밍을 생각해보면, 어떤 리스트의 값을 모두 더한다고 했을때 다음과 같은 코드를 실행한다.

```run-python
def sum(numbers):
	acc = 0
	for i in numbers:
		acc += i
	return acc

numbers = [1,2,3,4]
print(sum(numbers))
```
acc 라는 변수가 가변으로써, 동시성에서 자유롭지 못하다. 

```run-javascript
function sum(numbers) { 
	return numbers.reduce(
		(acc, num) => acc + num, 
		0
	)
		
} 
numbers = [1,2,3,4] //불변이라고 가정
console.log(sum(numbers))

```

하지만 이러한 함수는 가변변수에서 자유롭다. 

모 내 생각이지만, 함수형 프로그래밍을 잘하는건, 내장 함수를 잘 써서 최대한 공유 변수를 안쓰는 것 이지 않을까.

그니까 결국에, 가변 변수를 사용하지 않기 위해 함수형 프로그래밍이 나왔다고 보아도된다. 그럼으로써 **비교적 로우단** 동시성 문제가 해결되고, 외부 요인으로부터 안전한 프로그램을 작성할 수 있다. 몰론 유저단 논리적 동시성 문제는 당연히 해결 안된다. 

책에서는 이러한 함수형 프로그래밍이 클로저 언어의 예를 들어 병렬화의 용이성을 보여주고 있다. 

핵심 키워드는
- map vs pmap
	- pmap은 map이 하는 기능 (새로운 배열만들기)를 병렬적으로 수행함.(?)
	- 어차피 새 배열 만드는건 병렬로 수행되어도 상관 ㄴㄴ 
	- 그래서 더 빨라보이는데 찾아보니 오버헤드가 좀 있어서 상황에 맞게 잘 써야한다고 함.
- fold vs reduce
	- 둘다 축소 함수
	- 다만 fold는 이진 트리 기반, reduce 는 순차적으로.
	- fold가 훨씬 빠름
- lazy list(?)
	- 실제 계산이 수행되기 전에는 실 배열이 생성되지 않음.

결론
- 함수형 프로그래밍은 **가변상태를 애초에 내포하지 않음**으로, 동시성 문제에서 자유로움.
- 함수형 프로그래밍은 **참조 투명성**을 가짐으로써, 계산 순서를 막 바꿀수 있으므로 병렬화에 더욱 용이함.